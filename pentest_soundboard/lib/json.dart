class JsonPath {
  const JsonPath(this.pathItems);

  final List<JsonPathItem<Object?, Object?>> pathItems;

  JsonPath subPath<Key extends Object, Value extends Object>(Key key) =>
      JsonPath([
        ...pathItems,
        JsonPathItem<Key, Value>(key),
      ]);

  T? _read<T extends Object?>(
    Object? o,
    List<JsonPathItem<Object?, Object?>> pathItems,
  ) {
    if (pathItems.isEmpty) {
      if (o is T?) return o;
      throw ArgumentError('$o is not a $T');
    }
    if (o is! Map) {
      throw ArgumentError('$o is not a map');
    }
    final pathItem = pathItems.first;
    return _read(
      pathItem.read(o),
      pathItems.sublist(1),
    );
  }

  T? read<T extends Object?>(Map<Object?, Object?> map) =>
      _read(map, pathItems);

  void _write(
    Object? o,
    Object? value,
    List<JsonPathItem<Object?, Object?>> pathItems,
  ) {
    if (pathItems.isEmpty) {
      throw ArgumentError('Invalid path: ${this.pathItems}');
    }
    if (o is! Map) {
      throw ArgumentError('$o is not a map');
    }
    final pathItem = pathItems.first;
    if (pathItems.length == 1) {
      pathItem.write(o, value);
      return;
    }
    final nestedMap =
        pathItem.read(o) ?? pathItem.write(o, pathItems[1].newMap());
    _write(
      nestedMap,
      value,
      pathItems.sublist(1),
    );
  }

  void write(
    Map<Object?, Object?> map,
    Object? value,
  ) =>
      _write(map, value, pathItems);
}

class JsonPathItem<Key extends Object, T extends Object?> {
  const JsonPathItem(this.key);

  final Key key;

  Map<Key, T> newMap() => {};
  Map<Key, T> cast(Map<Object?, Object?> map) => map.cast();

  T? read(Map<Object?, Object?> map) => cast(map)[key];
  Object? write(Map<Object?, Object?> map, Object? value) => map[key] = value;
}
