import 'dart:io';

import 'package:analysis_server_lib/analysis_server_lib.dart';
import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/visitor.dart';
import 'package:code_builder/code_builder.dart';
import 'package:collection/collection.dart';
import 'package:path/path.dart' as path;
import 'package:stream_transform/stream_transform.dart';

Future<Directory> get rootDir async {
  var dir = Directory.current;
  while (dir.parent != dir) {
    final files = dir.list(followLinks: false).whereType<File>();
    await for (final file in files) {
      if (path.basename(file.path) == 'mono_repo.yaml') {
        return dir;
      }
    }
    dir = dir.parent;
  }
  throw StateError(
    'Root directory not found. Make sure to run this command '
    'from within the Amplify Flutter repo',
  );
}

Future<void> main() async {
  final repoRoot = (await rootDir).path;
  final corePath = path.join(
    repoRoot,
    'packages',
    'amplify_core',
  );
  final authPath = path.join(
    repoRoot,
    'packages',
    'auth',
    'amplify_auth_cognito_dart',
  );
  final includedPaths = [
    ...await Directory(corePath)
        .list(recursive: true, followLinks: false)
        .whereType<File>()
        .map((file) => file.path)
        .toList(),
    ...await Directory(authPath)
        .list(recursive: true, followLinks: false)
        .whereType<File>()
        .map((file) => file.path)
        .toList(),
  ];
  final contextCollection = AnalysisContextCollection(
    includedPaths: includedPaths,
  );
  final server = await AnalysisServer.create();
  final pluginInterfacePath = path.join(
    corePath,
    'lib',
    'src',
    'plugin',
    'amplify_auth_plugin_interface.dart',
  );
  final pluginInterfaceCtx = contextCollection.contextFor(pluginInterfacePath);
  final result = await pluginInterfaceCtx.currentSession
      .getResolvedLibrary(pluginInterfacePath) as ResolvedLibraryResult;
  final visitor = Visitor(authPath, server);
  result.element.accept(visitor);
}

class Visitor extends RecursiveElementVisitor<void> {
  Visitor(this.authPath, this.server);

  final String authPath;
  final AnalysisServer server;
  final Map<String, Class> modals = {};

  @override
  void visitMethodElement(MethodElement element) async {
    if (element.kind == ElementKind.GETTER) {
      return;
    }
    var returnType = element.returnType;
    assert(
      returnType.isDartAsyncFuture && returnType is ParameterizedType,
      () => 'Unexpected return type: $returnType',
    );
    returnType = (returnType as ParameterizedType).typeArguments.single;

    var requestType = element.parameters.singleOrNull?.type;
    if (requestType == null) {
      return;
    }
    final requestTypeHierarchy = await server.search.getTypeHierarchy(
      requestType.element!.source!.uri.toString(),
      requestType.element!.nameOffset,
    );
    final requestTypeSubclasses =
        requestTypeHierarchy.hierarchyItems?.first.subclasses;
    if (requestTypeSubclasses != null && requestTypeSubclasses.isNotEmpty) {
      print(
          'Hierarchy for $requestType: ${requestTypeSubclasses.map((ty) => requestTypeHierarchy.hierarchyItems![ty])}');
      final resultTypeClass = requestTypeHierarchy
          .hierarchyItems![requestTypeSubclasses.last].classElement;
      final resultTypeLibrary = await element.session!.getResolvedLibrary(
        resultTypeClass.location!.file,
      ) as ResolvedLibraryResult;
      requestType = resultTypeLibrary.element.topLevelElements
          .whereType<ClassElement>()
          .single
          .thisType;
    } else {
      print('No type hierarchy for: ');
    }
    print('${element.name}: $requestType $returnType');

    // modals[element.name] = Class((c) {});
    return;
  }
}
